<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="5135d11c-4477-45d6-bd83-15c94c120edb" name="Default" comment="" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="xhr_test.cljc" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/test/tiltontec/xhr_test.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="30">
              <caret line="445" column="5" lean-forward="false" selection-start-line="445" selection-start-column="5" selection-end-line="445" selection-end-column="5" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.cljs" pinned="false" current-in-tab="false">
        <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojurescript/1.7.228/clojurescript-1.7.228.jar!/cljs/core.cljs">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="269">
              <caret line="7947" column="6" lean-forward="false" selection-start-line="7947" selection-start-column="6" selection-end-line="7947" selection-end-column="6" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="xhr.cljc" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/tiltontec/xhr.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="229">
              <caret line="131" column="21" lean-forward="true" selection-start-line="131" selection-start-column="21" selection-end-line="131" selection-end-column="21" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="synapse.cljc" pinned="false" current-in-tab="false">
        <entry file="file://$USER_HOME$/matrix/cljs/matrix/src/tiltontec/cell/synapse.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="269">
              <caret line="44" column="33" lean-forward="false" selection-start-line="44" selection-start-column="33" selection-end-line="44" selection-end-column="33" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>xhr.core</find>
      <find>md-making</find>
      <find>example.com</find>
      <find>await-sleeping</find>
      <find>now</find>
      <find>:xhr-send-is-sending-uri</find>
      <find>:no-response-xhr-await-sleeping-max</find>
      <find>oops</find>
      <find>-type</find>
      <find>&lt;cget</find>
      <find>family</find>
      <find>xhr</find>
      <find>opts!!!</find>
      <find>synapse</find>
      <find>xhr!!!</find>
      <find>ing-uri</find>
      <find>syn!</find>
      <find>:making-syn!?</find>
    </findStrings>
    <replaceStrings>
      <replace>xhr</replace>
      <replace>fn</replace>
    </replaceStrings>
    <dirStrings>
      <dir>$PROJECT_DIR$</dir>
      <dir>$PROJECT_DIR$/src</dir>
      <dir>$PROJECT_DIR$/test</dir>
    </dirStrings>
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/checkouts/matrix/src/tiltontec/cell/observer.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/xhr.cljc" />
        <option value="$USER_HOME$/matrix/cljs/matrix/src/tiltontec/cell/synapse.cljc" />
        <option value="$PROJECT_DIR$/test/tiltontec/xhr_test.cljc" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="139" />
    <option name="y" value="105" />
    <option name="width" value="1494" />
    <option name="height" value="922" />
  </component>
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="Scratches" />
      <pane id="PackagesPane" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="xhr" type="b2602c69:ProjectViewProjectNode" />
              <item name="xhr" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="xhr" type="b2602c69:ProjectViewProjectNode" />
              <item name="xhr" type="462c0819:PsiDirectoryNode" />
              <item name="checkouts" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="xhr" type="b2602c69:ProjectViewProjectNode" />
              <item name="xhr" type="462c0819:PsiDirectoryNode" />
              <item name="checkouts" type="462c0819:PsiDirectoryNode" />
              <item name="matrix" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="xhr" type="b2602c69:ProjectViewProjectNode" />
              <item name="xhr" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="xhr" type="b2602c69:ProjectViewProjectNode" />
              <item name="xhr" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="tiltontec" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="xhr" type="b2602c69:ProjectViewProjectNode" />
              <item name="xhr" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="cbhell.java" type="529ef68f:ClassesTreeStructureProvider$PsiClassOwnerTreeNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.sourceCode.Clojure" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
  </component>
  <component name="ReplState" timestamp="1517444101833">{:repl-history {:ide [], :local [{:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n\n   (cond\n     (xhr-response xhr)\n     (do                                                    ;;(println :xhr-resolved (xhr-response xhr))\n       ;;(cpr :xhr-resolved (xhrfo xhr))\n       xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (cpr :no-response-xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout\n                (fn []\n                  (cpr :xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                  (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! max-seconds (xhrfo xhr))\n                  xhr))))&quot;, :offset 746, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(ns tiltontec.xhr\n  #?(:cljs (:require-macros [cljs.core.async.macros :refer [go]]))\n  (:require\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n\n    [tiltontec.util.core :refer [pln countit]]\n\n    #?(:cljs [tiltontec.cell.base\n              :refer-macros [pcell un-stopped without-c-dependency cpr\n                             with-cc]\n\n              :refer [+pulse+ c-pulse c-optimized-away?\n                      mdead? md-ref?\n                      +client-q-handler+ c-stopped unbound\n                      *within-integrity* *defer-changes*\n                      *depender* caller-ensure]]\n       :clj\n    [tiltontec.cell.base :refer :all])\n\n    [tiltontec.cell.evaluate :refer [not-to-be not-to-be-self]]\n\n    #?(:cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []]\n       :clj [tiltontec.cell.synapse :refer :all])\n\n    #?(:cljs [tiltontec.cell.integrity\n              :refer-macros [with-cc with-integrity]\n              :refer []]\n       :clj\n    [tiltontec.cell.integrity :refer :all])\n\n    #?(:cljs [tiltontec.util.base\n              :refer-macros [trx prog1 *trx?* def-rmap-slots]]\n       :clj\n    [tiltontec.util.base\n     :refer :all])\n\n    ; cool------------------------\n\n    #?(:clj [tiltontec.cell.observer :refer [fn-obs observe observe-by-type type-cljc]]\n       :cljs [tiltontec.cell.observer\n              :refer-macros [fn-obs]\n              :refer [observe observe-by-type type-cljc]])\n\n    ;cool-----\n\n    #?(:clj\n    [tiltontec.cell.core :refer :all]\n       :cljs [tiltontec.cell.core\n              :refer-macros [c? c?+ c_? c?_]\n              :refer [c-in c-reset! make-c-formula ]])\n\n    [tiltontec.model.core\n     :refer-macros [the-kids mdv!]\n     :refer [md-get fasc fm! make md-reset! backdoor-reset!\n             mx-par]\n     :as md]\n\n    ;cool------\n\n\n    #?(:clj\n    [clj-http.client :as client]\n       :cljs [cljs-http.client :as client])\n\n    #?(:clj\n    [cheshire.core :refer :all]\n       :cljs [cognitect.transit :as t])\n\n    [clojure.walk :refer [keywordize-keys]]\n\n    #?(:cljs [cljs.core.async :refer [&lt;!]])\n    ))&quot;, :offset 2127, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr/xhr\n                    :id (swap! +xhr-sid+ inc)               ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :body-parser (:body-parser attrs #(#?(:clj parse-json$ :cljs identity) %))\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                     ;; (pln :sel-sees-body!! (md-get me :select) b)\n                                     (if-let [ks (md-get me :select)]\n                                       (select-keys b ks)\n                                       b)))\n                    (vec (apply concat (seq (dissoc attrs :send? :body-parser)))))]\n     (println :xhr-made!!!!!!!!!! uri (type-cljc xhr))\n     #_ (when (:send? attrs)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 994, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(deftest fda-adderall-ok\n  (cells-init)\n  (let [xhr (xhr-await (make-xhr ae-adderall {:send? true}))]\n    (assert xhr)\n    (is (= 200 (xhr-status xhr)))\n    (is (= 3 (count (:results (xhr-selection xhr)))))\n    (let [ae (first (:results (xhr-selection xhr)))]\n      (pln :ae (keys ae))\n      (pprint (select-keys ae [:primarysourcecountry\n                               :transmissiondate\n                               :sender\n                               :companynumb\n                               :serious\n                               :occurcountry]))\n      (pprint (keys (:patient ae))))))&quot;, :offset 597, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr/xhr\n                    :id (swap! +xhr-sid+ inc)               ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :body-parser (:body-parser attrs #(#?(:clj parse-json$ :cljs identity) %))\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                     ;; (pln :sel-sees-body!! (md-get me :select) b)\n                                     (if-let [ks (md-get me :select)]\n                                       (select-keys b ks)\n                                       b)))\n                    (vec (apply concat (seq (dissoc attrs #_ :send? :body-parser)))))]\n     (println :xhr-made!!!!!!!!!! uri (type-cljc xhr))\n     #_ (when (:send? attrs)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 997, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defmethod observe [:send? :tiltontec.xhr/xhr] [_ me newv oldv _]\n  ;; (println :observing-xhr!!!! newv (:uri @me))\n  (when newv\n    (println :send?-observer-sending-xhr!!!!!!!!!!!!!)\n    (xhr-send me)))&quot;, :offset 203, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defmethod observe [:kids :tiltontec.xhr/xhr] [_ me newv oldv _]\n  ;;\n  (when (not= oldv unbound)\n    ;; oldv unbound means initial build and this incremental add/remove\n    ;; is needed only when kids change post initial creation\n    ;; todo flesh this out\n    (let [lost (clojure.set/difference (set oldv) (set newv))\n          gained (clojure.set/difference (set newv) (set oldv))]\n\n      (cond\n        (empty? gained)\n            ;; just lose the lost\n        (do)\n\n        :default                                            ;; try to cancel?\n        (pln :ignoring-new-kid-xhrs!!!!!!! newv)))))&quot;, :offset 600, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(deftest fda-adderall-ok\n  (cells-init)\n  (let [xhr (xhr-await (make-xhr ae-adderall {:send? (c-in true)}))]\n    (assert xhr)\n    (is (= 200 (xhr-status xhr)))\n    (is (= 3 (count (:results (xhr-selection xhr)))))\n    (let [ae (first (:results (xhr-selection xhr)))]\n      ;;(pln :ae!!! (keys ae))\n      (pprint (select-keys ae [:primarysourcecountry\n                               :transmissiondate\n                               :sender\n                               :companynumb\n                               :serious\n                               :occurcountry]))\n      (pprint (keys (:patient ae))))))&quot;, :offset 609, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest fda-yanks-ng\n  (cells-init)\n  (let [xhr (xhr-await (make-xhr ae-yabba))]\n    (is (= 404 (xhr-status xhr)))\n    (is (nil? (:results (xhr-selection xhr))))\n    (pln :ae )\n    (pprint @xhr)))&quot;, :offset 197, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-dummy [options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      (println :latting lat)\n                      (Thread/sleep lat))\n                    (:response options))}))&quot;, :offset 270, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(def xt (atom {:send-time nil}))&quot;, :offset 32, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn now []\n  #?(:clj (System/currentTimeMillis)\n     :cljs (.getTime (js/Date.))))&quot;, :offset 84, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(swap! xt update-in :send-time (now))&quot;, :offset 37, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(update {:a 0} :a 42)&quot;, :offset 21, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(update-in {:a 0} [:a] 42)&quot;, :offset 26, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(swap! xt update :send-time assoc (now))&quot;, :offset 40, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(swap! xt assoc :send-time  (now))&quot;, :offset 34, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n   (assert (:send-time @xhr) \&quot;XHR never sent\&quot;)\n   (cond\n     (xhr-response xhr)\n     (do                                                    ;;(println :xhr-resolved (xhr-response xhr))\n       ;;(cpr :xhr-resolved (xhrfo xhr))\n       xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (cpr :no-response-xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout\n                (fn []\n                  (cpr :xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                  (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! max-seconds (xhrfo xhr))\n                  xhr))))&quot;, :offset 792, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(deftest xhr-reactx\n  ;; \&quot;responseA\&quot; &lt;- f1\n  ;; 100 &lt;- f2\n  ;; f3 &lt;- f1\n  ;; f4,f5 &lt;- f2\n  ;; ff &lt;- f3, f4, f5\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})]\n    (xhr-await f1)\n    (is = (xhr-response \&quot;responseA\&quot;)))\n  )&quot;, :offset 296, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-dummy [options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:send? true?\n     :body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      (println :latting lat)\n                      (Thread/sleep lat))\n                    (:response options))}))&quot;, :offset 288, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-is-sending-uri uri)\n    (#?(:clj alter :cljs swap!) xhr assoc :send-time (now))\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                ;(cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (countit [:xhr :reponse])\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do\n                    ;;(cpr :hitting-with-cc *within-integrity*)\n                    (with-cc :xhr-handler-sets-responded\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body   ((:body-parser @xhr) (:body response))})))))\n              (fn [exception]\n                (countit [:xhr :exception])\n                (cpr \&quot;xhr-send&gt; raw exception\&quot; exception)\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-json$ (:body edata)))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-json$ (:body edata))}))))))\n\n       :cljs (go (let [response (&lt;! (client/get uri {:with-credentials? false}))]\n                   (if (:success response)\n                     (do\n                       ;(prn :body (keys (:body response)))\n                       ;(prn :success (:status response)  (keys response) (count (:body response)))\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (js/setTimeout\n                             #(do\n                                (when-let [d (:fake-delay @xhr)]\n                                  (println :fake-delayed!!!!!! d))\n                                (md-reset! xhr :response\n                                  {:status (:status response)\n                                   :body   ((:body-parser @xhr) (:body response))}))\n                             (or (:fake-delay @xhr) 0)))))\n\n                     (do\n                       (prn :NO-success :stat (:status response) :ecode (:error-code response)\n                            :etext (:error-text response))\n\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (md-reset! xhr :response {:status (:status response)\n                                                     :body   [(:error-code response)\n                                                              (:error-text response)]}))))))))))&quot;, :offset 2927, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-dummy [options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:send? true?\n     :body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      (println :latting lat)\n                      (Thread/sleep lat))\n                    (let [r (:response options)]\n                      (if (fn? r)\n                        (r (:params options))\n                        r)))}))&quot;, :offset 405, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-dummy [options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:send? true?\n     :body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      (println :latting lat)\n                      (Thread/sleep lat))\n                    (let [r (:response options)]\n                      (println :opts!!!!! options)\n                      (if (fn? r)\n                        (r (:params options))\n                        r)))}))&quot;, :offset 456, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; \&quot;responseA\&quot; &lt;- f1\n  ;; 100 &lt;- f2\n  ;; f3 &lt;- f1\n  ;; f4,f5 &lt;- f2\n  ;; ff &lt;- f3, f4, f5\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f3 (xhr-dummy\n             {:id :service-c\n              :params {:f1 (:body (xhr-response f1))}\n              :latency 60\n              :response #(str \&quot;responseB-\&quot; (:f1 %))})]\n    (xhr-await f1)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    (println :wtf (:body (xhr-response f3)))\n    (is (not (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))))\n  )&quot;, :offset 611, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; \&quot;responseA\&quot; &lt;- f1\n  ;; 100 &lt;- f2\n  ;; f3 &lt;- f1\n  ;; f4,f5 &lt;- f2\n  ;; ff &lt;- f3, f4, f5\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f3 (xhr-dummy\n             {:id :service-c\n              :params {:f1 (:body (xhr-response f1))}\n              :latency 60\n              :response #(str \&quot;responseB-\&quot; (:f1 %))})]\n    (xhr-await f1)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    (println :wtf (:body (xhr-response f3)))\n    ;;(is (not (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))))\n  ))&quot;, :offset 614, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (xhr-dummy\n             {:id :service-c\n              :params {:f1 r1}\n              :latency 60\n              :response #(str \&quot;responseB-\&quot; (:f1 %))})))]\n    (xhr-await f3)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))\n  ))&quot;, :offset 619, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f2 (xhr-dummy\n             {:id       :service-b\n              :latency  40\n              :response 100})\n\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (println :dispatching-f3!!!!!!!!!!!)\n                 (xhr-dummy\n                   {:id       :service-c\n                    :params   {:f1 r1}\n                    :latency  60\n                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))]\n    (xhr-await f3)\n    ;(xhr-await f2)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    ;(is (= (:body (xhr-response f2)) 100))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))\n    ))&quot;, :offset 887, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-is-sending-uri uri)\n    (#?(:clj alter :cljs swap!) xhr assoc :send-time (now))\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                (cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (countit [:xhr :reponse])\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do\n                    ;;(cpr :hitting-with-cc *within-integrity*)\n                    (with-cc :xhr-handler-sets-responded\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body   ((:body-parser @xhr) (:body response))})))))\n              (fn [exception]\n                (countit [:xhr :exception])\n                (cpr \&quot;xhr-send&gt; raw exception\&quot; exception)\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-json$ (:body edata)))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-json$ (:body edata))}))))))\n\n       :cljs (go (let [response (&lt;! (client/get uri {:with-credentials? false}))]\n                   (if (:success response)\n                     (do\n                       ;(prn :body (keys (:body response)))\n                       ;(prn :success (:status response)  (keys response) (count (:body response)))\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (js/setTimeout\n                             #(do\n                                (when-let [d (:fake-delay @xhr)]\n                                  (println :fake-delayed!!!!!! d))\n                                (md-reset! xhr :response\n                                  {:status (:status response)\n                                   :body   ((:body-parser @xhr) (:body response))}))\n                             (or (:fake-delay @xhr) 0)))))\n\n                     (do\n                       (prn :NO-success :stat (:status response) :ecode (:error-code response)\n                            :etext (:error-text response))\n\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (md-reset! xhr :response {:status (:status response)\n                                                     :body   [(:error-code response)\n                                                              (:error-text response)]}))))))))))&quot;, :offset 2926, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-dummy [options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:id (:id options)\n     :send?       true\n     :body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      (println :latting lat)\n                      (Thread/sleep lat))\n                    (let [r (:response options)]\n                      (println :opts!!!!! options)\n                      (if (fn? r)\n                        (r (:params options))\n                        r)))}))&quot;, :offset 484, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-is-sending-uri (:id @xhr) uri)\n    (#?(:clj alter :cljs swap!) xhr assoc :send-time (now))\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                (cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (countit [:xhr :reponse])\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do\n                    ;;(cpr :hitting-with-cc *within-integrity*)\n                    (with-cc :xhr-handler-sets-responded\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body   ((:body-parser @xhr) (:body response))})))))\n              (fn [exception]\n                (countit [:xhr :exception])\n                (cpr \&quot;xhr-send&gt; raw exception\&quot; exception)\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-json$ (:body edata)))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-json$ (:body edata))}))))))\n\n       :cljs (go (let [response (&lt;! (client/get uri {:with-credentials? false}))]\n                   (if (:success response)\n                     (do\n                       ;(prn :body (keys (:body response)))\n                       ;(prn :success (:status response)  (keys response) (count (:body response)))\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (js/setTimeout\n                             #(do\n                                (when-let [d (:fake-delay @xhr)]\n                                  (println :fake-delayed!!!!!! d))\n                                (md-reset! xhr :response\n                                  {:status (:status response)\n                                   :body   ((:body-parser @xhr) (:body response))}))\n                             (or (:fake-delay @xhr) 0)))))\n\n                     (do\n                       (prn :NO-success :stat (:status response) :ecode (:error-code response)\n                            :etext (:error-text response))\n\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (md-reset! xhr :response {:status (:status response)\n                                                     :body   [(:error-code response)\n                                                              (:error-text response)]}))))))))))&quot;, :offset 2937, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n   (cond\n     (xhr-response xhr)\n     (do                                                    ;;(println :xhr-resolved (xhr-response xhr))\n       ;;(cpr :xhr-resolved (xhrfo xhr))\n       xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (cpr :no-response-xhr-await-sleeping-max (:id @xhr) max-seconds (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout\n                (fn []\n                  (cpr :xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                  (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! max-seconds (xhrfo xhr))\n                  xhr))))&quot;, :offset 756, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n   (cond\n     (xhr-response xhr)\n     (do                                                    ;;(println :xhr-resolved (xhr-response xhr))\n       ;;(cpr :xhr-resolved (xhrfo xhr))\n       xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (cpr :no-response-xhr-await-sleeping-max (:id @xhr) (:uri @xhr) @xhr max-seconds (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout\n                (fn []\n                  (cpr :xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                  (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! max-seconds (xhrfo xhr))\n                  xhr))))&quot;, :offset 773, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n   (cond\n     (nil? xhr)\n     (do (println :xhr-await-passed-nil))\n     \n     (xhr-response xhr)\n     (do                                                    ;;(println :xhr-resolved (xhr-response xhr))\n       ;;(cpr :xhr-resolved (xhrfo xhr))\n       xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (cpr :no-response-xhr-await-sleeping-max (:id @xhr) (:uri @xhr) @xhr max-seconds (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout\n                (fn []\n                  (cpr :xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                  (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! max-seconds (xhrfo xhr))\n                  xhr))))&quot;, :offset 837, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n   (cond\n     (not (= ::xhr (type-cljc xhr)))\n     (do (println :xhr-await-passed-non-xhr))\n\n     (xhr-response xhr)\n     (do                                                    ;;(println :xhr-resolved (xhr-response xhr))\n       ;;(cpr :xhr-resolved (xhrfo xhr))\n       xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (cpr :no-response-xhr-await-sleeping-max (:id @xhr) (:uri @xhr) @xhr max-seconds (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout\n                (fn []\n                  (cpr :xhr-await-sleeping-max max-seconds (xhrfo xhr))\n                  (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! max-seconds (xhrfo xhr))\n                  xhr))))&quot;, :offset 857, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f2 (xhr-dummy\n             {:id       :service-b\n              :latency  40\n              :response 100})\n\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (println :dispatching-f3!!!!!!!!!!!)\n                 (xhr-dummy\n                   {:id       :service-c\n                    :params   {:f1 r1}\n                    :latency  60\n                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))]\n    (xhr-await (&lt;cget f1))\n    ;(xhr-await f2)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    ;(is (= (:body (xhr-response f2)) 100))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))\n    ))&quot;, :offset 895, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f2 (xhr-dummy\n             {:id       :service-b\n              :latency  40\n              :response 100})\n\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (println :dispatching-f3!!!!!!!!!!!)\n                 (xhr-dummy\n                   {:id       :service-c\n                    :params   {:f1 r1}\n                    :latency  60\n                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))]\n    (xhr-await (&lt;cget f1))\n    ;(xhr-await f2)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    ;(is (= (:body (xhr-response f2)) 100))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))\n    (println :fini)))&quot;, :offset 910, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f2 (xhr-dummy\n             {:id       :service-b\n              :latency  40\n              :response 100})\n\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (println :dispatching-f3!!!!!!!!!!! r1)\n                 (xhr-dummy\n                   {:id       :service-c\n                    :params   {:f1 r1}\n                    :latency  60\n                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))]\n    (xhr-await f1)\n    ;(xhr-await f2)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    (xhr-await (&lt;cget f3))\n    ;(is (= (:body (xhr-response f2)) 100))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response f3)) \&quot;responseB-responseA\&quot;))\n    (println :fini)))&quot;, :offset 932, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f2 (xhr-dummy\n             {:id       :service-b\n              :latency  40\n              :response 100})\n\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (println :dispatching-f3!!!!!!!!!!! r1)\n                 (xhr-dummy\n                   {:id       :service-c\n                    :params   {:f1 r1}\n                    :latency  60\n                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))]\n    (xhr-await f1)\n    ;(xhr-await f2)\n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    (xhr-await (&lt;cget f3))\n    ;(is (= (:body (xhr-response f2)) 100))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response (&lt;cget f3))) \&quot;responseB-responseA\&quot;))\n    (println :fini)))&quot;, :offset 940, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-reactx-oops\n  ;; oops. f1 not populated when response sampled for f3. duh.\n  (let [f1 (xhr-dummy\n             {:id       :service-a\n              :latency  100\n              :response \&quot;responseA\&quot;})\n        f2 (xhr-dummy\n             {:id       :service-b\n              :latency  40\n              :response 100})\n\n        f3 (c? (when-let [r1 (:body (xhr-response f1))]\n                 (println :dispatching-f3!!!!!!!!!!! r1)\n                 (xhr-dummy\n                   {:id       :service-c\n                    :params   {:f1 r1}\n                    :latency  60\n                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n        ]\n    ;(xhr-await f1)\n    ;(xhr-await f2)\n    (xhr-await (&lt;cget f3))\n    \n    (is (= (:body (xhr-response f1)) \&quot;responseA\&quot;))\n    ;(is (= (:body (xhr-response f2)) 100))\n    ;(println :wtf (:body (xhr-response f3)))\n    (is (= (:body (xhr-response (&lt;cget f3))) \&quot;responseB-responseA\&quot;))\n    (println :fini)))&quot;, :offset 955, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-dummy [options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:id (:id options)\n     :send?       true\n     :kids (:kids options)\n     :body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      (println :latency-sim lat)\n                      (Thread/sleep lat))\n                    (let [r (:response options)]\n                      (println :opts!!!!! options)\n                      (if (fn? r)\n                        (r (:params options))\n                        r)))}))&quot;, :offset 515, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn fn-await\n  ([fn] (fn-await :anon fn))\n  ([tag fn] (fn-await tag fn 3))\n  ([tag fn max-seconds]\n   (or (fn)\n     (if (&gt; max-seconds 0)\n       #?(:clj  (do\n                  (cpr :no-response-xhr-await-sleeping-max max-seconds tag)\n                  (Thread/sleep 1000)\n                  (recur fn-await (dec max-seconds)))\n          :cljs (js/setTimeout\n                  (fn []\n                      (cpr :fn-await-sleeping-max max-seconds tag)\n                      (fn-await tag fn (dec max-seconds))) 1000))\n\n       (do (println :fn-await-timeout! max-seconds tag)\n           nil)))))&quot;, :offset 593, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn fn-await\n  ([fn] (fn-await :anon fn))\n  ([tag fn] (fn-await tag fn 3))\n  ([tag fn max-seconds]\n   (or (fn)\n     (if (&gt; max-seconds 0)\n       #?(:clj  (do\n                  (cpr :no-response-xhr-await-sleeping-max max-seconds tag)\n                  (Thread/sleep 1000)\n                  (recur tag fn (dec max-seconds)))\n          :cljs (js/setTimeout\n                  (fn []\n                      (cpr :fn-await-sleeping-max max-seconds tag)\n                      (fn-await tag fn (dec max-seconds))) 1000))\n\n       (do (println :fn-await-timeout! max-seconds tag)\n           nil)))))&quot;, :offset 591, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make ::md/family\n              :result (c? (when (every? xhr-response (&lt;mget me :kids))\n                            (map #(:body (xhr-response %)) (&lt;mget me :kids))))\n              :kids (c? (the-kids\n                          (xhr-dummy\n                            {:id       :f1-service-a\n                             :latency  100\n                             :response \&quot;responseA\&quot;\n                             ;:kids     (c? (cpr :kidrule!!!!!!)\n                             ;              (when-let [r1 (:body (xhr-response (mx-par me)))]\n                             ;                (println :making-f3!!!! r1)\n                             ;                (the-kids\n                             ;                  (xhr-dummy\n                             ;                    {:id       :service-c\n                             ;                     :params   {:f1 r1}\n                             ;                     :latency  60\n                             ;                     :response #(str \&quot;responseB-\&quot; (:f1 %))}))))\n                             })\n                          (xhr-dummy\n                            {:id       :f2-service-b\n                             :latency  40\n                             :response 100})\n\n                          )))]\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))))&quot;, :offset 1398, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make ::md/family\n              :result (c? (cpr :cking-rs)\n                          (when (every? xhr-response (&lt;mget me :kids))\n                            (cpr :got-rs)\n                            (map #(:body (xhr-response %)) (&lt;mget me :kids))))\n              :kids (c? (the-kids\n                          (xhr-dummy\n                            {:id       :f1-service-a\n                             :latency  100\n                             :response \&quot;responseA\&quot;\n                             ;:kids     (c? (cpr :kidrule!!!!!!)\n                             ;              (when-let [r1 (:body (xhr-response (mx-par me)))]\n                             ;                (println :making-f3!!!! r1)\n                             ;                (the-kids\n                             ;                  (xhr-dummy\n                             ;                    {:id       :service-c\n                             ;                     :params   {:f1 r1}\n                             ;                     :latency  60\n                             ;                     :response #(str \&quot;responseB-\&quot; (:f1 %))}))))\n                             })\n                          (xhr-dummy\n                            {:id       :f2-service-b\n                             :latency  40\n                             :response 100})\n\n                          )))]\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1502, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n              :f2 (xhr-dummy\n                    {:id       :f2-service-b\n                     :latency  40\n                     :response 100})\n              \n              \n              :result (c? (cpr :cking-rs)\n                          (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2])]\n                            (when (every? rs)\n                              (cpr :got-rs)\n                              (map :body rs)))))]\n\n                             ;:kids     (c? (cpr :kidrule!!!!!!)\n                             ;              (when-let [r1 (:body (xhr-response (mx-par me)))]\n                             ;                (println :making-f3!!!! r1)\n                             ;                (the-kids\n                             ;                  (xhr-dummy\n                             ;                    {:id       :service-c\n                             ;                     :params   {:f1 r1}\n                             ;                     :latency  60\n                             ;                     :response #(str \&quot;responseB-\&quot; (:f1 %))}))))\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1408, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n              :f2 (xhr-dummy\n                    {:id       :f2-service-b\n                     :latency  40\n                     :response 100})\n\n\n              :result (c? (cpr :cking-rs)\n                          (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2])]\n                            (when (every? rs)\n                              (cpr :got-rs)\n                              (map :body rs)))))]\n\n                             ;:kids     (c? (cpr :kidrule!!!!!!)\n                             ;              (when-let [r1 (:body (xhr-response (mx-par me)))]\n                             ;                (println :making-f3!!!! r1)\n                             ;                (the-kids\n                             ;                  (xhr-dummy\n                             ;                    {:id       :service-c\n                             ;                     :params   {:f1 r1}\n                             ;                     :latency  60\n                             ;                     :response #(str \&quot;responseB-\&quot; (:f1 %))}))))\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1380, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n              :f2 (c? (xhr-dummy\n                    {:id       :f2-service-b\n                     :latency  40\n                     :response 100}))\n\n\n              :result (c? (cpr :cking-rs)\n                          (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2])]\n                            (when (every? identity rs)\n                              (cpr :got-rs)\n                              (map :body rs)))))]\n\n                             ;:kids     (c? (cpr :kidrule!!!!!!)\n                             ;              (when-let [r1 (:body (xhr-response (mx-par me)))]\n                             ;                (println :making-f3!!!! r1)\n                             ;                (the-kids\n                             ;                  (xhr-dummy\n                             ;                    {:id       :service-c\n                             ;                     :params   {:f1 r1}\n                             ;                     :latency  60\n                             ;                     :response #(str \&quot;responseB-\&quot; (:f1 %))}))))\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1394, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n              \n              :f2 (c? (xhr-dummy\n                    {:id       :f2-service-b\n                     :latency  40\n                     :response 100}))\n              \n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! r1)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n\n              :result (c? (cpr :cking-rs)\n                          (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])]\n                            (when (every? identity rs)\n                              (cpr :got-rs)\n                              (map :body rs)))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1146, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n              \n              :f2 (c? (xhr-dummy\n                    {:id       :f2-service-b\n                     :latency  40\n                     :response 100}))\n              \n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n\n              :result (c? (cpr :cking-rs)\n                          (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])]\n                            (when (every? identity rs)\n                              (cpr :got-rs)\n                              (map :body rs)))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1147, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy\n                        {:id       :f2-service-b\n                         :latency  40\n                         :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n\n              :result (c? (when (&lt;mget me :f1)\n                            (cpr :cking-rs)\n                            (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])]\n                              (when (every? identity rs)\n                                (cpr :got-rs)\n                                (map :body rs))))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1189, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy\n                        {:id       :f2-service-b\n                         :latency  40\n                         :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n\n              :result (c? (when (&lt;mget me :f3)\n                            (cpr :cking-rs)\n                            (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])]\n                              (when (every? identity rs)\n                                (cpr :got-rs)\n                                (map :body rs))))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1189, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy\n                        {:id       :f2-service-b\n                         :latency  40\n                         :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n              \n              :f4 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                        (println :making-f4!!!! f2v)\n                        (xhr-dummy\n                          {:id       :service-d\n                           :params   {:f2 f2v}\n                           :latency  140\n                           :response #(+ 40 (:f2 %))})))\n\n\n              :result (c? (when (every? #(&lt;mget me %) [:f3 :f4])\n                            (cpr :cking-rs)\n                            (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3 :f4])]\n                              (when (every? identity rs)\n                                (cpr :got-rs)\n                                (map :body rs))))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1583, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy\n                        {:id       :f2-service-b\n                         :latency  40\n                         :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n              :f4 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                        (println :making-f4!!!! f2v)\n                        (xhr-dummy\n                          {:id       :service-d\n                           :params   {:f2 f2v}\n                           :latency  140\n                           :response #(+ 40 (:f2 %))})))\n\n              :f5 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                        (println :making-f5!!!! f2v)\n                        (xhr-dummy\n                          {:id       :service-e\n                           :params   {:f2 f2v}\n                           :latency  55\n                           :response #(+ 5000 (:f2 %))})))\n\n\n              :result (c? (when (every? #(&lt;mget me %) [:f3 :f4 :f5])\n                            (cpr :cking-rs)\n                            (let [rs (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3 :f4 :f5])]\n                              (when (every? identity rs)\n                                (cpr :got-rs)\n                                (map :body rs))))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1936, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy\n                        {:id       :f1-service-a\n                         :latency  100\n                         :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy\n                        {:id       :f2-service-b\n                         :latency  40\n                         :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy\n                          {:id       :service-c\n                           :params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n              :f45 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                          (println :making-f4-f5!!!! f2v)\n                          (vector\n                            (xhr-dummy\n                              {:id       :service-d\n                               :params   {:f2 f2v}\n                               :latency  140\n                               :response #(+ 40 (:f2 %))})\n                            (xhr-dummy\n                              {:id       :service-e\n                               :params   {:f2 f2v}\n                               :latency  55\n                               :response #(+ 5000 (:f2 %))}))))\n\n\n              :result (c? (when (and (every? #(&lt;mget me %) [:f3 :f45]) \n                                     (every? xhr-response (&lt;mget me :f45)))\n                            (cpr :cking-rs)\n                            (let [rs (concat (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])\n                                             (map xhr-response (&lt;mget me :f45)))]\n                              (when (every? identity rs)\n                                (cpr :got-rs)\n                                (map :body rs))))))]\n\n    (println :bam)\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 2045, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree\n  (let [top (make\n              :f1 (c? (xhr-dummy :f1-service-a\n                        {:latency  100\n                         :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy :f2-service-b\n                        {:latency  40\n                         :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (println :making-f3!!!! f1v)\n                        (xhr-dummy :service-c\n                          {:params   {:f1 f1v}\n                           :latency  60\n                           :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n              :f45 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                          (println :making-f4-f5!!!! f2v)\n                          (vector\n                            (xhr-dummy :service-d\n                              {:params   {:f2 f2v}\n                               :latency  140\n                               :response #(+ 40 (:f2 %))})\n                            (xhr-dummy :service-e\n                              {:params   {:f2 f2v}\n                               :latency  55\n                               :response #(+ 5000 (:f2 %))}))))\n\n\n              :result (c? (when (and (every? #(&lt;mget me %) [:f3 :f45])\n                                     (every? xhr-response (&lt;mget me :f45)))\n                            (let [rs (concat (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])\n                                             (map xhr-response (&lt;mget me :f45)))]\n                              (when (every? identity rs)\n                                (map :body rs))))))]\n    \n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1750, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defn xhr-dummy [id options]\n  (make-xhr \&quot;http://example.com\&quot;\n    {:id          id\n     :send?       true\n     :kids        (:kids options)\n     :body-parser (fn [b]\n                    (when-let [lat (:latency options)]\n                      ;(println :latency-sim lat)\n                      (Thread/sleep lat))\n                    (let [r (:response options)]\n                      ;(println :opts!!!!! options)\n                      (if (fn? r)\n                        (r (:params options))\n                        r)))}))&quot;, :offset 525, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (when-let [youtube (xhr-await (with-synapse (:s-tube)\n                                  (xhr-html \&quot;http://youtube.com\&quot;)))]\n    (cpr :youtube! (xhrfo youtube))))&quot;, :offset 279, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (when-let [youtube (xhr-await (do ;; with-synapse (:s-tube)\n                                  (xhr-html \&quot;http://youtube.com\&quot;)))]\n    (cpr :youtube! (xhrfo youtube))))&quot;, :offset 285, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 1 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (when-let [google (xhr-await (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://google.com\&quot;)))]\n\n                      (list google)))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 1 (count r)))\n        (is (every? #(= 200 (xhr-status %)) r)))\n      (println :topfini (map xhrfo (c-get xhrs-cell))))))&quot;, :offset 1057, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 1 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (when-let [google (xhr-await (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://youtube.com\&quot;)))]\n\n                      (list google)))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 1 (count r)))\n        (is (every? #(= 200 (xhr-status %)) r)))\n      (println :topfini (map xhrfo (c-get xhrs-cell))))))&quot;, :offset 1058, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n  (when-let [google (xhr-await (with-synapse (:s-goog)\n                                 (xhr-html \&quot;http://youtube.com\&quot;)))]\n\n    (list google))\n  #_\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 1 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (when-let [google (xhr-await (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://youtube.com\&quot;)))]\n\n                      (list google)))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 1 (count r)))\n        (is (every? #(= 200 (xhr-status %)) r)))\n      (println :topfini (map xhrfo (c-get xhrs-cell))))))&quot;, :offset 1206, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n  (when-let [google (xhr-await (do ;;with-synapse (:s-goog)\n                                 (xhr-html \&quot;http://youtube.com\&quot;)))]\n\n    (list google))\n  #_\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 1 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (when-let [google (xhr-await (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://youtube.com\&quot;)))]\n\n                      (list google)))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 1 (count r)))\n        (is (every? #(= 200 (xhr-status %)) r)))\n      (println :topfini (map xhrfo (c-get xhrs-cell))))))&quot;, :offset 1211, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defmethod observe [:send? :tiltontec.xhr/xhr] [_ me newv oldv _]\n  (println :observing-xhr!!!! newv (:uri @me))\n  (when newv\n    (println :send?-observer-sending-xhr!!!!!!!!!!!!!)\n    (xhr-send me)))&quot;, :offset 200, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 1 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (when-let [google (xhr-response (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://youtube.com\&quot;)))]\n\n                      (list google)))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 1 (count r)))\n        (is (every? #(= 200 (xhr-status %)) r)))\n      (println :topfini (map xhrfo (c-get xhrs-cell))))))&quot;, :offset 1061, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-hack\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 1 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (let [google (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://youtube.com\&quot;))]\n                      (when (xhr-response google)\n                        (list google))))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 1 (count r)))\n        (is (every? #(= 200 (xhr-status %)) r)))\n      (println :topfini (map xhrfo (c-get xhrs-cell))))))&quot;, :offset 1093, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest xhr-sequentially\n  ;; kick off one at a time waiting for the prior to complete before sending next.\n  (cells-init)\n\n  (let [xhrs-cell (c?+ [:slot :synch!\n                        :obs (fn-obs (when new\n                                       (println :fini!!! (map xhrfo new))\n                                       (is (= 3 (count new)))\n                                       (is (every? #(= :responded (xhr-status-key %)) new))))]\n\n                    (when-let [google (xhr-response (with-synapse (:s-goog)\n                                                   (xhr-html \&quot;http://google.com\&quot;)))]\n\n                      (when-let [yahoo (xhr-response (with-synapse (:s-yahoo)\n                                                    (xhr-html \&quot;http://yahoo.com\&quot;)))]\n                        (when-let [youtube (xhr-response (with-synapse (:s-tube)\n                                                        (xhr-html \&quot;http://youtube.com\&quot;)))]\n                          (cpr :youtube! youtube)\n                          (list google yahoo youtube)))))]\n    ;; cf-await means cell-formulaic await. Although the body above shows xhr-wait, that\n    ;; is just the body of the cell. In cf-await we patiently wait for the cell formula to\n    ;; return a non-nil value, and\n\n    (let [r (cf-await xhrs-cell)]\n      (is (not (nil? r)))\n      (when r\n        (is (= 3 (count r)))\n        (is (every? #(= 200 (:status %)) r)))\n      (println :topfini r))))&quot;, :offset 1442, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree-2\n  (let [top (make\n              :f1 (c? (xhr-dummy :f1-service-a\n                                 {:latency  100\n                                  :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy :f2-service-b\n                                 {:latency  40\n                                  :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (xhr-dummy :service-c\n                                   {:params   {:f1 f1v}\n                                    :latency  60\n                                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n              :f45 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                         (pcpr :building-245!!!!!!!!!!!!!!!!!!!!!!)\n                         (vector\n                           (xhr-dummy :service-d\n                                      {:params   {:f2 f2v}\n                                       :latency  140\n                                       :response #(+ 40 (:f2 %))})\n                           (xhr-dummy :service-e\n                                      {:params   {:f2 f2v}\n                                       :latency  55\n                                       :response #(+ 5000 (:f2 %))}))))\n\n\n              :result (c? (when (and (every? #(&lt;mget me %) [:f3 :f45])\n                                     (every? xhr-response (&lt;mget me :f45)))\n                            (let [rs (concat (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])\n                                             (map xhr-response (&lt;mget me :f45)))]\n                              (when (every? identity rs)\n                                (map :body rs))))))]\n\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1813, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-tree-2\n  (let [top (make\n              :f1 (c? (xhr-dummy :f1-service-a\n                                 {:latency  100\n                                  :response \&quot;responseA\&quot;}))\n\n              :f2 (c? (xhr-dummy :f2-service-b\n                                 {:latency  40\n                                  :response 100}))\n\n              :f3 (c? (when-let [f1v (:body (xhr-response (&lt;mget me :f1)))]\n                        (xhr-dummy :service-c\n                                   {:params   {:f1 f1v}\n                                    :latency  60\n                                    :response #(str \&quot;responseB-\&quot; (:f1 %))})))\n\n              :f45 (c? (when-let [f2v (:body (xhr-response (&lt;mget me :f2)))]\n                         (cpr :building-245!!!!!!!!!!!!!!!!!!!!!!)\n                         (vector\n                           (xhr-dummy :service-d\n                                      {:params   {:f2 f2v}\n                                       :latency  140\n                                       :response #(+ 40 (:f2 %))})\n                           (xhr-dummy :service-e\n                                      {:params   {:f2 f2v}\n                                       :latency  55\n                                       :response #(+ 5000 (:f2 %))}))))\n\n\n              :result (c? (when (and (every? #(&lt;mget me %) [:f3 :f45])\n                                     (every? xhr-response (&lt;mget me :f45)))\n                            (let [rs (concat (map #(xhr-response (&lt;mget me %)) [:f1 :f2 :f3])\n                                             (map xhr-response (&lt;mget me :f45)))]\n                              (when (every? identity rs)\n                                (map :body rs))))))]\n\n    (let [r (fn-await :top #(:result @top))]\n      (println :boom r))\n    (println :fini)))&quot;, :offset 1812, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;              ;:f1 (c? (xhr-dummy :f1-service-a\n              ;                   {:latency  100\n              ;                    :response \&quot;responseA\&quot;}))&quot;, :offset 156, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-snb\n  ;; kick off  requests and return them one at a time in order received.\n  (cells-init)\n  (let [h (c? (merge\n                (when-let [f1v (with-xhr-body :get-f1\n                                 (xhr-dummy :f1-service-a\n                                   {:latency  100\n                                    :response \&quot;responseA\&quot;}))]\n                  {:f1 f1v\n                   :f3 (with-xhr-body :get-f3\n                         (xhr-dummy :service-c\n                           {:params   {:f1 f1v}\n                            :latency  60\n                            :response #(str \&quot;responseB-\&quot; (:f1 %))}))})\n               (when-let [f2v (with-xhr-body :get-f2\n                                (xhr-dummy :f2-service-b\n                                  {:latency  40\n                                   :response 100}))]\n                 {:f2 f2v\n                  :f4 (with-xhr-body :get-f4\n                        (xhr-dummy :service-d\n                          {:params   {:f2 f2v}\n                           :latency  140\n                           :response #(+ 40 (:f2 %))}))})))]\n    \n\n    #_ (let [r (&lt;cget h)]\n      (is (= \&quot;responseA\&quot; (:f1 r)))\n      (is (= \&quot;responseB-responseA\&quot; (:f3 r))))\n\n    (println :f1-f3 (&lt;cget h))\n    ))&quot;, :offset 1261, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-snb\n  ;; kick off  requests and return them one at a time in order received.\n  (cells-init)\n  (let [h (c? (let [f15 (merge\n                (when-let [f1v (with-xhr-body :get-f1\n                                 (xhr-dummy :f1-service-a\n                                   {:latency  100\n                                    :response \&quot;responseA\&quot;}))]\n                  {:f1 f1v\n                   :f3 (with-xhr-body :get-f3\n                         (xhr-dummy :service-c\n                           {:params   {:f1 f1v}\n                            :latency  60\n                            :response #(str \&quot;responseB-\&quot; (:f1 %))}))})\n                (when-let [f2v (with-xhr-body :get-f2\n                                 (xhr-dummy :f2-service-b\n                                   {:latency  40\n                                    :response 100}))]\n                  {:f2 f2v\n                   :f4 (with-xhr-body :get-f4\n                         (xhr-dummy :service-d\n                           {:params   {:f2 f2v}\n                            :latency  140\n                            :response #(+ 40 (:f2 %))}))}))]\n                (let [out (select-keys f15 [:f1 :f3 :f5])]\n                  (when (not-any? nil? (vals out))\n                    out))))]\n\n\n    #_(let [r (&lt;cget h)]\n        (is (= \&quot;responseA\&quot; (:f1 r)))\n        (is (= \&quot;responseB-responseA\&quot; (:f3 r))))\n\n    (dotimes [n 5]\n      (println :f1-f3!!!!!!!!!!! (&lt;cget h))\n      (Thread/sleep 40))))&quot;, :offset 1470, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(select-keys {} [:a])&quot;, :offset 21, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(vals (select-keys {} [:a]))&quot;, :offset 28, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(deftest reactx-snb\n  ;; kick off  requests and return them one at a time in order received.\n  (cells-init)\n  (let [h (c? (let [f15 (merge\n                          (when-let [f1v (with-xhr-body :get-f1\n                                           (xhr-dummy :f1-service-a\n                                             {:latency  100\n                                              :response \&quot;responseA\&quot;}))]\n                            {:f1 f1v\n                             :f3 (with-xhr-body :get-f3\n                                   (xhr-dummy :service-c\n                                     {:params   {:f1 f1v}\n                                      :latency  60\n                                      :response #(str \&quot;responseB-\&quot; (:f1 %))}))})\n                          (when-let [f2v (with-xhr-body :get-f2\n                                           (xhr-dummy :f2-service-b\n                                             {:latency  40\n                                              :response 100}))]\n                            {:f2 f2v\n                             :f4 (with-xhr-body :get-f4\n                                   (xhr-dummy :service-d\n                                     {:params   {:f2 f2v}\n                                      :latency  140\n                                      :response #(+ 40 (:f2 %))}))}))]\n                \n                (let [must [:f1 :f3 :f5]\n                      out (select-keys f15 must)\n                      vals (vals out)]\n                  (when (and (= (count vals) (count must))\n                             (not-any? nil? vals))\n                    (println :coool-out!!!! out)\n                    out))))]\n\n\n    #_(let [r (&lt;cget h)]\n        (is (= \&quot;responseA\&quot; (:f1 r)))\n        (is (= \&quot;responseB-responseA\&quot; (:f3 r))))\n\n    (cf-await h)\n    (dotimes [n 5]\n      (println :f1-f3!!!!!!!!!!! (&lt;cget h))\n      (Thread/sleep 40))))&quot;, :offset 1882, :ns &quot;tiltontec.xhr-test&quot;} {:command &quot;(defmethod observe [:send? :tiltontec.xhr/xhr] [_ me newv oldv _]\n  ;;(println :observing-xhr!!!! newv (:uri @me))\n  (when newv\n    ;;;(println :send?-observer-sending-xhr!!!!!!!!!!!!!)\n    (xhr-send me)))&quot;, :offset 205, :ns &quot;tiltontec.xhr&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    ;; (cpr :xhr-send-is-sending-uri (:id @xhr) uri)\n    (#?(:clj alter :cljs swap!) xhr assoc :send-time (now))\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                ;; (cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (countit [:xhr :reponse])\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do\n                    ;;(cpr :hitting-with-cc *within-integrity*)\n                    (with-cc :xhr-handler-sets-responded\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body   ((:body-parser @xhr) (:body response))})))))\n              (fn [exception]\n                (countit [:xhr :exception])\n                ;; (cpr \&quot;xhr-send&gt; raw exception\&quot; exception)\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-json$ (:body edata)))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-json$ (:body edata))}))))))\n\n       :cljs (go (let [response (&lt;! (client/get uri {:with-credentials? false}))]\n                   (if (:success response)\n                     (do\n                       ;(prn :body (keys (:body response)))\n                       ;(prn :success (:status response)  (keys response) (count (:body response)))\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (js/setTimeout\n                             #(do\n                                (when-let [d (:fake-delay @xhr)]\n                                  (println :fake-delayed!!!!!! d))\n                                (md-reset! xhr :response\n                                  {:status (:status response)\n                                   :body   ((:body-parser @xhr) (:body response))}))\n                             (or (:fake-delay @xhr) 0)))))\n\n                     (do\n                       (prn :NO-success :stat (:status response) :ecode (:error-code response)\n                            :etext (:error-text response))\n\n                       (if (mdead? xhr)\n                         (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                         (with-cc :xhr-handler-sets-responded\n                           (md-reset! xhr :response {:status (:status response)\n                                                     :body   [(:error-code response)\n                                                              (:error-text response)]}))))))))))&quot;, :offset 2946, :ns &quot;tiltontec.xhr&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.Unnamed">
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="xhr" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="5135d11c-4477-45d6-bd83-15c94c120edb" name="Default" comment="" />
      <created>1517160529605</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1517160529605</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="139" y="105" width="1494" height="922" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.39156628" sideWeight="0.5" order="3" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="false" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.24966533" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32941177" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="combo" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.38487282" sideWeight="0.5" order="4" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="false" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.24966533" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32941177" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <option name="time" value="2" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/test/tiltontec/xhr_test.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="7350">
          <caret line="490" column="38" lean-forward="false" selection-start-line="490" selection-start-column="38" selection-end-line="490" selection-end-column="38" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/model/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1560">
          <caret line="104" column="7" lean-forward="false" selection-start-line="104" selection-start-column="7" selection-end-line="104" selection-end-column="7" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/xhr.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="2640">
          <caret line="176" column="6" lean-forward="false" selection-start-line="176" selection-start-column="6" selection-end-line="176" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/tiltontec/xhr_test.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/xhr.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="2640">
          <caret line="176" column="6" lean-forward="false" selection-start-line="176" selection-start-column="6" selection-end-line="176" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/model/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1560">
          <caret line="104" column="7" lean-forward="false" selection-start-line="104" selection-start-column="7" selection-end-line="104" selection-end-column="7" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/tiltontec/xhr_test.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/xhr.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="3795">
          <caret line="253" column="6" lean-forward="false" selection-start-line="253" selection-start-column="6" selection-end-line="253" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/model/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1560">
          <caret line="104" column="7" lean-forward="false" selection-start-line="104" selection-start-column="7" selection-end-line="104" selection-end-column="7" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/XHR.md">
      <provider selected="true" editor-type-id="split-provider[text-editor;markdown-preview-editor]">
        <state split_layout="SPLIT">
          <first_editor relative-caret-position="167">
            <caret line="35" column="21" lean-forward="false" selection-start-line="35" selection-start-column="21" selection-end-line="35" selection-end-column="21" />
          </first_editor>
          <second_editor />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/checkouts/matrix/src/tiltontec/cell/observer.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="633">
          <caret line="44" column="10" lean-forward="false" selection-start-line="44" selection-start-column="10" selection-end-line="44" selection-end-column="10" />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/cell/observer.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="270">
          <caret line="44" column="5" lean-forward="false" selection-start-line="44" selection-start-column="5" selection-end-line="44" selection-end-column="5" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/cbhell.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="-837">
          <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="13" selection-end-line="7" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/cell/base.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="274">
          <caret line="70" column="10" lean-forward="false" selection-start-line="70" selection-start-column="10" selection-end-line="70" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/model/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="274">
          <caret line="99" column="6" lean-forward="false" selection-start-line="99" selection-start-column="6" selection-end-line="99" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/com/tiltontec/matrix/0.1.1-SNAPSHOT/matrix-0.1.1-SNAPSHOT.jar!/tiltontec/cell/synapse.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="269">
          <caret line="37" column="10" lean-forward="false" selection-start-line="37" selection-start-column="10" selection-end-line="37" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojurescript/1.7.228/clojurescript-1.7.228.jar!/cljs/core.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="269">
          <caret line="7947" column="6" lean-forward="false" selection-start-line="7947" selection-start-column="6" selection-end-line="7947" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$USER_HOME$/matrix/cljs/matrix/src/tiltontec/cell/synapse.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="269">
          <caret line="44" column="33" lean-forward="false" selection-start-line="44" selection-start-column="33" selection-end-line="44" selection-end-column="33" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/xhr.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="229">
          <caret line="131" column="21" lean-forward="true" selection-start-line="131" selection-start-column="21" selection-end-line="131" selection-end-column="21" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/tiltontec/xhr_test.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="30">
          <caret line="445" column="5" lean-forward="false" selection-start-line="445" selection-start-column="5" selection-end-line="445" selection-end-column="5" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>